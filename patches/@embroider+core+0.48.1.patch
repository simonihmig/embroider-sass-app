diff --git a/node_modules/@embroider/core/src/html-entrypoint.js b/node_modules/@embroider/core/src/html-entrypoint.js
index 3187043..5b79a98 100644
--- a/node_modules/@embroider/core/src/html-entrypoint.js
+++ b/node_modules/@embroider/core/src/html-entrypoint.js
@@ -1,144 +1,146 @@
-"use strict";
-var __importDefault = (this && this.__importDefault) || function (mod) {
-    return (mod && mod.__esModule) ? mod : { "default": mod };
-};
-Object.defineProperty(exports, "__esModule", { value: true });
+'use strict';
+var __importDefault =
+  (this && this.__importDefault) ||
+  function (mod) {
+    return mod && mod.__esModule ? mod : { default: mod };
+  };
+Object.defineProperty(exports, '__esModule', { value: true });
 exports.HTMLEntrypoint = void 0;
-const shared_internals_1 = require("@embroider/shared-internals");
-const fs_extra_1 = require("fs-extra");
-const path_1 = require("path");
-const jsdom_1 = require("jsdom");
-const partition_1 = __importDefault(require("lodash/partition"));
-const zip_1 = __importDefault(require("lodash/zip"));
-const html_placeholder_1 = __importDefault(require("./html-placeholder"));
+const shared_internals_1 = require('@embroider/shared-internals');
+const fs_extra_1 = require('fs-extra');
+const path_1 = require('path');
+const jsdom_1 = require('jsdom');
+const partition_1 = __importDefault(require('lodash/partition'));
+const zip_1 = __importDefault(require('lodash/zip'));
+const html_placeholder_1 = __importDefault(require('./html-placeholder'));
 class HTMLEntrypoint {
-    constructor(pathToVanillaApp, rootURL, publicAssetURL, filename) {
-        this.pathToVanillaApp = pathToVanillaApp;
-        this.rootURL = rootURL;
-        this.publicAssetURL = publicAssetURL;
-        this.filename = filename;
-        this.placeholders = new Map();
-        this.modules = [];
-        this.scripts = [];
-        this.styles = [];
-        this.dom = new jsdom_1.JSDOM((0, fs_extra_1.readFileSync)((0, path_1.join)(this.pathToVanillaApp, this.filename), 'utf8'));
-        for (let tag of this.handledStyles()) {
-            let styleTag = tag;
-            let href = styleTag.href;
-            if (!isAbsoluteURL(href)) {
-                let url = this.relativeToApp(href);
-                this.styles.push(url);
-                let placeholder = new html_placeholder_1.default(styleTag);
-                let list = (0, shared_internals_1.getOrCreate)(this.placeholders, url, () => []);
-                list.push(placeholder);
-            }
-        }
-        for (let scriptTag of this.handledScripts()) {
-            // scriptTag.src include rootURL. Convert it to be relative to the app.
-            let src = this.relativeToApp(scriptTag.src);
-            if (scriptTag.type === 'module') {
-                this.modules.push(src);
-            }
-            else {
-                this.scripts.push(src);
-            }
-            let placeholder = new html_placeholder_1.default(scriptTag);
-            let list = (0, shared_internals_1.getOrCreate)(this.placeholders, src, () => []);
-            list.push(placeholder);
-        }
+  constructor(pathToVanillaApp, rootURL, publicAssetURL, filename) {
+    this.pathToVanillaApp = pathToVanillaApp;
+    this.rootURL = rootURL;
+    this.publicAssetURL = publicAssetURL;
+    this.filename = filename;
+    this.placeholders = new Map();
+    this.modules = [];
+    this.scripts = [];
+    this.styles = [];
+    this.dom = new jsdom_1.JSDOM(
+      (0, fs_extra_1.readFileSync)((0, path_1.join)(this.pathToVanillaApp, this.filename), 'utf8')
+    );
+    for (let tag of this.handledStyles()) {
+      let styleTag = tag;
+      let href = styleTag.href;
+      if (!isAbsoluteURL(href)) {
+        let url = this.relativeToApp(href);
+        this.styles.push(url);
+        let placeholder = new html_placeholder_1.default(styleTag);
+        let list = (0, shared_internals_1.getOrCreate)(this.placeholders, url, () => []);
+        list.push(placeholder);
+      }
     }
-    relativeToApp(rootRelativeURL) {
-        return rootRelativeURL.replace(this.rootURL, '');
+    for (let scriptTag of this.handledScripts()) {
+      // scriptTag.src include rootURL. Convert it to be relative to the app.
+      let src = this.relativeToApp(scriptTag.src);
+      if (scriptTag.type === 'module') {
+        this.modules.push(src);
+      } else {
+        this.scripts.push(src);
+      }
+      let placeholder = new html_placeholder_1.default(scriptTag);
+      let list = (0, shared_internals_1.getOrCreate)(this.placeholders, src, () => []);
+      list.push(placeholder);
     }
-    handledScripts() {
-        let scriptTags = [...this.dom.window.document.querySelectorAll('script')];
-        let [ignoredScriptTags, handledScriptTags] = (0, partition_1.default)(scriptTags, scriptTag => {
-            return !scriptTag.src || scriptTag.hasAttribute('data-embroider-ignore') || isAbsoluteURL(scriptTag.src);
-        });
-        for (let scriptTag of ignoredScriptTags) {
-            scriptTag.removeAttribute('data-embroider-ignore');
-        }
-        return handledScriptTags;
+  }
+  relativeToApp(rootRelativeURL) {
+    return rootRelativeURL.replace(this.rootURL, '');
+  }
+  handledScripts() {
+    let scriptTags = [...this.dom.window.document.querySelectorAll('script')];
+    let [ignoredScriptTags, handledScriptTags] = (0, partition_1.default)(scriptTags, (scriptTag) => {
+      return !scriptTag.src || scriptTag.hasAttribute('data-embroider-ignore') || isAbsoluteURL(scriptTag.src);
+    });
+    for (let scriptTag of ignoredScriptTags) {
+      scriptTag.removeAttribute('data-embroider-ignore');
     }
-    handledStyles() {
-        let styleTags = [...this.dom.window.document.querySelectorAll('link[rel="stylesheet"]')];
-        let [ignoredStyleTags, handledStyleTags] = (0, partition_1.default)(styleTags, styleTag => {
-            return !styleTag.href || styleTag.hasAttribute('data-embroider-ignore') || isAbsoluteURL(styleTag.href);
-        });
-        for (let styleTag of ignoredStyleTags) {
-            styleTag.removeAttribute('data-embroider-ignore');
-        }
-        return handledStyleTags;
+    return handledScriptTags;
+  }
+  handledStyles() {
+    let styleTags = [...this.dom.window.document.querySelectorAll('link[rel="stylesheet"]')];
+    let [ignoredStyleTags, handledStyleTags] = (0, partition_1.default)(styleTags, (styleTag) => {
+      return !styleTag.href || styleTag.hasAttribute('data-embroider-ignore') || isAbsoluteURL(styleTag.href);
+    });
+    for (let styleTag of ignoredStyleTags) {
+      styleTag.removeAttribute('data-embroider-ignore');
     }
-    // bundles maps from input asset to a per-variant map of output assets
-    render(stats) {
-        let insertedLazy = false;
-        let fastbootVariant = stats.variants.findIndex(v => Boolean(v.runtime === 'fastboot'));
-        let supportsFastboot = stats.variants.some(v => v.runtime === 'fastboot' || v.runtime === 'all');
-        for (let [src, placeholders] of this.placeholders) {
-            let match = stats.entrypoints.get(src);
-            if (match) {
-                let firstVariant = stats.variants.findIndex((_, index) => Boolean(match.get(index)));
-                let matchingBundles = match.get(firstVariant);
-                let matchingFastbootBundles = fastbootVariant >= 0 ? match.get(fastbootVariant) || [] : [];
-                for (let placeholder of placeholders) {
-                    if (supportsFastboot) {
-                        // if there is any fastboot involved, we will emit the lazy bundles
-                        // right before our first script.
-                        insertedLazy = maybeInsertLazyBundles(insertedLazy, stats.lazyBundles, placeholder, this.publicAssetURL);
-                    }
-                    for (let [base, fastboot] of (0, zip_1.default)(matchingBundles, matchingFastbootBundles)) {
-                        if (!base) {
-                            // this bundle only exists in the fastboot variant
-                            let element = placeholder.start.ownerDocument.createElement('fastboot-script');
-                            element.setAttribute('src', this.publicAssetURL + fastboot);
-                            placeholder.insert(element);
-                            placeholder.insertNewline();
-                        }
-                        else if (!fastboot || base === fastboot) {
-                            // no specialized fastboot variant
-                            let src = this.publicAssetURL + base;
-                            placeholder.insertURL(src);
-                        }
-                        else {
-                            // we have both and they differ
-                            let src = this.publicAssetURL + base;
-                            let element = placeholder.insertURL(src);
-                            if (element) {
-                                element.setAttribute('data-fastboot-src', this.publicAssetURL + fastboot);
-                            }
-                        }
-                    }
-                }
-            }
-            else {
-                // no match means keep the original HTML content for this placeholder.
-                // (If we really wanted it empty instead, there would be matchingBundles
-                // and it would be an empty list.)
-                for (let placeholder of placeholders) {
-                    placeholder.reset();
-                }
+    return handledStyleTags;
+  }
+  // bundles maps from input asset to a per-variant map of output assets
+  render(stats) {
+    let insertedLazy = false;
+    let fastbootVariant = stats.variants.findIndex((v) => Boolean(v.runtime === 'fastboot'));
+    let supportsFastboot = stats.variants.some((v) => v.runtime === 'fastboot' || v.runtime === 'all');
+    for (let [src, placeholders] of this.placeholders) {
+      let match = stats.entrypoints.get(src);
+      if (match) {
+        let firstVariant = stats.variants.findIndex((_, index) => Boolean(match.get(index)));
+        let matchingBundles = match.get(firstVariant);
+        let matchingFastbootBundles = fastbootVariant >= 0 ? match.get(fastbootVariant) || [] : [];
+        for (let placeholder of placeholders) {
+          if (supportsFastboot) {
+            // if there is any fastboot involved, we will emit the lazy bundles
+            // right before our first script.
+            insertedLazy = maybeInsertLazyBundles(insertedLazy, stats.lazyBundles, placeholder, this.publicAssetURL);
+          }
+          for (let [base, fastboot] of (0, zip_1.default)(matchingBundles, matchingFastbootBundles)) {
+            if (!base) {
+              // this bundle only exists in the fastboot variant
+              let element = placeholder.start.ownerDocument.createElement('fastboot-script');
+              element.setAttribute('src', this.publicAssetURL + fastboot);
+              placeholder.insert(element);
+              placeholder.insertNewline();
+            } else if (!fastboot || base === fastboot) {
+              // no specialized fastboot variant
+              let src = this.publicAssetURL + base;
+              placeholder.insertURL(src);
+            } else {
+              // we have both and they differ
+              let src = this.publicAssetURL + base;
+              let element = placeholder.insertURL(src);
+              if (element) {
+                element.setAttribute('data-fastboot-src', this.publicAssetURL + fastboot);
+              }
             }
+          }
         }
-        return this.dom.serialize();
+      } else {
+        // no match means keep the original HTML content for this placeholder.
+        // (If we really wanted it empty instead, there would be matchingBundles
+        // and it would be an empty list.)
+        for (let placeholder of placeholders) {
+          placeholder.reset();
+        }
+      }
     }
+    return this.dom.serialize();
+  }
 }
 exports.HTMLEntrypoint = HTMLEntrypoint;
 function isAbsoluteURL(url) {
-    return /^(?:[a-z]+:)?\/\//i.test(url);
+  return /^(?:[a-z]+:)?\/\//i.test(url);
 }
 // we (somewhat arbitrarily) decide to put the lazy bundles before the very
 // first <script> that we have rewritten
 function maybeInsertLazyBundles(insertedLazy, lazyBundles, placeholder, publicAssetURL) {
-    if (!insertedLazy && placeholder.isScript()) {
-        for (let bundle of lazyBundles) {
-            let element = placeholder.start.ownerDocument.createElement('fastboot-script');
-            element.setAttribute('src', publicAssetURL + bundle);
-            placeholder.insert(element);
-            placeholder.insertNewline();
-        }
-        return true;
+  if (!insertedLazy && placeholder.isScript()) {
+    for (let bundle of lazyBundles) {
+      if (bundle.endsWith('.js')) {
+        let element = placeholder.start.ownerDocument.createElement('fastboot-script');
+        element.setAttribute('src', publicAssetURL + bundle);
+        placeholder.insert(element);
+        placeholder.insertNewline();
+      }
     }
-    return insertedLazy;
+    return true;
+  }
+  return insertedLazy;
 }
 //# sourceMappingURL=html-entrypoint.js.map
\ No newline at end of file
diff --git a/node_modules/@embroider/core/src/html-placeholder.js b/node_modules/@embroider/core/src/html-placeholder.js
index 5039052..0c290c6 100644
--- a/node_modules/@embroider/core/src/html-placeholder.js
+++ b/node_modules/@embroider/core/src/html-placeholder.js
@@ -1,72 +1,82 @@
-"use strict";
-Object.defineProperty(exports, "__esModule", { value: true });
+'use strict';
+Object.defineProperty(exports, '__esModule', { value: true });
 class Placeholder {
-    // remove the target Element from the DOM, and track where it was so we can
-    // update that location later.
-    constructor(target) {
-        this.target = target;
-        if (!target.ownerDocument || !target.parentElement) {
-            throw new Error('can only construct a placeholder for an element that is in DOM');
-        }
-        let start = target.ownerDocument.createTextNode('');
-        target.parentElement.insertBefore(start, target);
-        let endNode = target.ownerDocument.createTextNode('');
-        target.replaceWith(endNode);
-        // Type cast is justified because start always has a nextSibling (it's
-        // "end") and because we know we already inserted the node.
-        this.start = start;
-        // Type cast is justified because we know we already inserted the node.
-        this.end = endNode;
+  // remove the target Element from the DOM, and track where it was so we can
+  // update that location later.
+  constructor(target) {
+    this.target = target;
+    if (!target.ownerDocument || !target.parentElement) {
+      throw new Error('can only construct a placeholder for an element that is in DOM');
     }
-    reset() {
-        this.clear();
-        this.insert(this.target);
+    let start = target.ownerDocument.createTextNode('');
+    target.parentElement.insertBefore(start, target);
+    let endNode = target.ownerDocument.createTextNode('');
+    target.replaceWith(endNode);
+    // Type cast is justified because start always has a nextSibling (it's
+    // "end") and because we know we already inserted the node.
+    this.start = start;
+    // Type cast is justified because we know we already inserted the node.
+    this.end = endNode;
+  }
+  reset() {
+    this.clear();
+    this.insert(this.target);
+  }
+  clear() {
+    while (this.start.nextSibling !== this.end) {
+      this.start.parentElement.removeChild(this.start.nextSibling);
     }
-    clear() {
-        while (this.start.nextSibling !== this.end) {
-            this.start.parentElement.removeChild(this.start.nextSibling);
-        }
+  }
+  insert(node) {
+    this.end.parentElement.insertBefore(node, this.end);
+  }
+  appendToHead(node) {
+    this.end.ownerDocument.head.appendChild(node);
+  }
+  isScript() {
+    return this.target.tagName === 'SCRIPT';
+  }
+  insertURL(url) {
+    if (url.endsWith('.js')) {
+      return this.insertScriptTag(url);
     }
-    insert(node) {
-        this.end.parentElement.insertBefore(node, this.end);
+    if (url.endsWith('.css')) {
+      return this.insertStyleLink(url);
     }
-    isScript() {
-        return this.target.tagName === 'SCRIPT';
+    throw new Error(`don't know how to insertURL ${url}`);
+  }
+  insertScriptTag(src) {
+    let newTag = this.end.ownerDocument.createElement('script');
+    for (let { name, value } of [...this.target.attributes]) {
+      if (name === 'type' && value === 'module') {
+        // we always convert modules to scripts
+        continue;
+      }
+      // all other attributes are copied forward unchanged
+      newTag.setAttribute(name, value);
     }
-    insertURL(url) {
-        if (url.endsWith('.js')) {
-            return this.insertScriptTag(url);
-        }
-        if (url.endsWith('.css')) {
-            return this.insertStyleLink(url);
-        }
-        throw new Error(`don't know how to insertURL ${url}`);
-    }
-    insertScriptTag(src) {
-        let newTag = this.end.ownerDocument.createElement('script');
-        for (let { name, value } of [...this.target.attributes]) {
-            if (name === 'type' && value === 'module') {
-                // we always convert modules to scripts
-                continue;
-            }
-            // all other attributes are copied forward unchanged
-            newTag.setAttribute(name, value);
-        }
-        newTag.src = src;
-        this.insert(newTag);
-        this.insertNewline();
-        return newTag;
-    }
-    insertStyleLink(href) {
-        let newTag = this.end.ownerDocument.createElement('link');
-        newTag.href = href;
-        newTag.rel = 'stylesheet';
-        this.insert(newTag);
-        this.insertNewline();
-    }
-    insertNewline() {
-        this.end.parentElement.insertBefore(this.end.ownerDocument.createTextNode('\n'), this.end);
+    newTag.src = src;
+    this.insert(newTag);
+    this.insertNewline();
+    return newTag;
+  }
+  insertStyleLink(href) {
+    let newTag = this.end.ownerDocument.createElement('link');
+    newTag.href = href;
+    newTag.rel = 'stylesheet';
+    if (this.isScript()) {
+      // Add dynamic styles from scripts to the bottom of the head, and not to where the script was,
+      // to prevent FOUC when pre-rendering (FastBoot)
+      this.appendToHead(newTag);
+    } else {
+      // Keep the new style in the same place as the original one
+      this.insert(newTag);
     }
+    this.insertNewline(newTag);
+  }
+  insertNewline(node = this.end) {
+    node.parentElement.insertBefore(node.ownerDocument.createTextNode('\n'), node);
+  }
 }
 exports.default = Placeholder;
 //# sourceMappingURL=html-placeholder.js.map
